<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Code">
<meta property="og:url" content="http://utilcoder.com/index.html">
<meta property="og:site_name" content="Code">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Code">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://utilcoder.com/"/>





  <title>Code</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Code</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/计算机网络学习/面经/计算机网络学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/计算机网络学习/面经/计算机网络学习/" itemprop="url">面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T15:12:16+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络学习/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>OSI七层网络模型</li>
</ul>
<p>应用层、表示层、会话层、传输层、网络层、链路层、物理层</p>
<ul>
<li>TCP和UDP</li>
</ul>
<p>TCP: 面向连接、可靠(有流量控制、拥塞控制)</p>
<p>UDP: 不连接、不可靠</p>
<ul>
<li>TCP编程</li>
</ul>
<p>服务器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用socket()创建一个socket</span><br><span class="line"></span><br><span class="line">用setsockopt()设置socket属性; </span><br><span class="line"></span><br><span class="line">用bind()绑定IP地址、端口等信息到socket;</span><br><span class="line"></span><br><span class="line">用listen()开启监听；</span><br><span class="line"></span><br><span class="line">用accept()接收客户端连接；</span><br><span class="line"></span><br><span class="line">用send()和recv()收发数据;</span><br><span class="line"></span><br><span class="line">关闭网络连接；</span><br><span class="line"></span><br><span class="line">关闭监听.</span><br></pre></td></tr></table></figure>
<p>客户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">用socket()创建一个socket</span><br><span class="line"></span><br><span class="line">用setsockopt()设置socket属性; </span><br><span class="line"></span><br><span class="line">用bind()绑定IP地址、端口等信息到socket;</span><br><span class="line"></span><br><span class="line">用connect()发送客户端连接；</span><br><span class="line"></span><br><span class="line">用send()和recv()收发数据;</span><br><span class="line"></span><br><span class="line">关闭网络连接；</span><br></pre></td></tr></table></figure>
<ul>
<li>UDP编程</li>
</ul>
<p>服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用socket()创建一个socket</span><br><span class="line"></span><br><span class="line">用setsockopt()设置socket属性; </span><br><span class="line"></span><br><span class="line">用bind()绑定IP地址、端口等信息到socket;</span><br><span class="line"></span><br><span class="line">用recvfroem()循环接收数据;</span><br><span class="line"></span><br><span class="line">关闭网络连接；</span><br></pre></td></tr></table></figure>
<p>客户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">用socket()创建一个socket</span><br><span class="line"></span><br><span class="line">用setsockopt()设置socket属性; </span><br><span class="line"></span><br><span class="line">用bind()绑定IP地址、端口等信息到socket;</span><br><span class="line"></span><br><span class="line">用sendto()发送数据;</span><br><span class="line"></span><br><span class="line">关闭网络连接；</span><br></pre></td></tr></table></figure>
<ul>
<li>端口</li>
</ul>
<p>端口是一个抽象的概念, 并没有真正的端口, 端口号看成某个进程的标识</p>
<ul>
<li><p>TCP三次握手</p>
<p>不携带数据, 只消耗一个序列号(用于流量控制, 当发生丢包可以将期望及以后的包重传)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Client: SYN = 1, seq = x</span><br><span class="line"></span><br><span class="line">Server: SYN = 1, ACK = 1, ack = x + 1, seq = y</span><br><span class="line"></span><br><span class="line">Client: ACK = 1, ack = y + 1, seq = x + 1</span><br></pre></td></tr></table></figure>
<p>为什么要三次握手:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为了防止失效的连接请求到底服务器</span><br><span class="line"></span><br><span class="line">假设客户端发送的第一次请求在网络中滞留，客户端得到不到相应后就会重新发送请求建立连接。假设第一次无效的连接，很久后又到达了服务器，假设只有两次握手，则这时服务的就会进入连接建立状态，而客户端却认为这次请求是无效的</span><br></pre></td></tr></table></figure>
<ul>
<li>TCP四次挥手</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Client: FIN = 1, seq = x</span><br><span class="line"></span><br><span class="line">Server: FIN = 1, ACK = 1, ack = x + 1, seq = y</span><br><span class="line"></span><br><span class="line">服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输的数据都传输完毕. 当服务器端传输完毕后, 向客户端发送断开连接的请求</span><br><span class="line"></span><br><span class="line">Server: FIN = 1, ACK = 1, ack = x + 1, seq = z</span><br><span class="line"></span><br><span class="line">Client: FIN = 1, ACK = 1, ack = z + 1, seq = x + 1</span><br></pre></td></tr></table></figure>
<p>为什么要四次挥手</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</span><br></pre></td></tr></table></figure>
<ul>
<li>TIME_WAIT</li>
</ul>
<p>客户端在发送完第四次挥手后，不是立马进入CLOSE状态，而是进入持续2MSL(最大报文段寿命)的TIME_WAIT阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 确保最后一个确认报文能够到达。如果没能到达，服务端就会会重发FIN请求释放连接, 客户端再发送一次LAST ack信号</span><br><span class="line"></span><br><span class="line">2. 让本连接所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文</span><br></pre></td></tr></table></figure>
<p><strong>TIME_WAIT</strong> 表示主动关闭，<strong>CLOSE_WAIT</strong> 表示被动关闭</p>
<ul>
<li>socket半关闭</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当A发送给B控制FIN的时候，A到B这个方向的连接就关闭了，这个时候处于半关闭的状态</span><br><span class="line"></span><br><span class="line">当B将数据全部发送完毕之后才会发送FIN给A, 此时socket全关闭</span><br></pre></td></tr></table></figure>
<ul>
<li>TCP拥塞控制</li>
</ul>
<p>防止过多的数据注入到网络中</p>
<p>慢开始(指数增长): 刚建立连接时, cwnd = 1, 每经过一个RTT, cwnd翻倍(若翻倍后cwnd &gt; ssthresh， cwnd=ssthresh), 进入拥塞避免阶段</p>
<p>拥塞避免: cwnd = ssthresh时, 每经过一个RTT, cwnd加1. 当超时, ssthresh = cwnd / 2, cwnd = 1, 进入慢开始阶段</p>
<p>快重传, 快恢复: 当收到三个冗余ACK, 不必等待重传计时器超时, 直接重传, cwnd = ssthresh = cwnd / 2, 进入拥塞避免阶段</p>
<ul>
<li>流量控制</li>
</ul>
<p>接收方控制发送方的发送速率</p>
<p>停止等待: 发送方发送后等待确认, 期间不能发送其他帧, WT = WR = 1</p>
<p>后退N帧: 发送方可以一次发送多个帧, 接收方一次只能接受一个帧, 若不是期望的帧, 则要求重发期望及以后的帧, WT &gt; 1, WR = 1</p>
<p>选择重传: 发送方可以一次发送多个帧, 接收方等窗口中所有帧到齐后一并交付, 只重传超时和出错的帧, WT &gt; 1, WR &gt; 1</p>
<ul>
<li>滑动窗口</li>
</ul>
<p>在流量控制中, 滑动窗口存储允许发送/接收的帧编号</p>
<ul>
<li>TCP可靠传输机制</li>
</ul>
<p>流量控制、拥塞控制、检验和、超时重传</p>
<ul>
<li>HTTP</li>
</ul>
<p>无状态协议</p>
<p>HTTP1.0: 非持久连接, 每个网页元素比如图像都要单独建立TCP连接</p>
<p>HTTP1.1: 持久连接. 支持流水线传输, 还没收到响应就能继续发送请求</p>
<p>HTTP2.0: 支持 HTTP 首部压缩, 支持服务端推送, 即在客户端请求之前发送数据以便缓存的机制</p>
<p>访问URL的过程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DNS解析获取IP地址</span><br><span class="line"></span><br><span class="line">建立TCP连接</span><br><span class="line"></span><br><span class="line">发送HTTP请求</span><br><span class="line"></span><br><span class="line">获取HTTP响应</span><br><span class="line"></span><br><span class="line">释放TCP连接</span><br></pre></td></tr></table></figure>
<ul>
<li>HTTP方法</li>
</ul>
<p>GET: 获取数据的请求. 请求会附加在URL上, 数据长度受限制, 不安全</p>
<p>POST: 修改服务器上的资源的请求. 请求放在请求中</p>
<p>PUT: 向指定资源位置上传其最新内容 </p>
<p>DELETE: 删除URL所标识的资源</p>
<ul>
<li>HTTP状态码</li>
</ul>
<p>200 OK</p>
<p>301 Moved Permanently 永久重定向，资源已永久分配新URI</p>
<p>400 Bad Request 请求报文语法错误或参数错误</p>
<p>404 Not Found 无法找到请求资源</p>
<p>2表示成功, 3表示重定向, 4表示客户端错误, 5表示服务器端错误</p>
<ul>
<li>HTTPS</li>
</ul>
<p>HTTPS = HTTP + TLS和 SSL</p>
<p>HTTP是明文传输, 而 HTTPS 将明文内容进行了加密</p>
<p>HTTPS同时使用对称加密和非对称加密. </p>
<p>非对称加密用于在双方传递密钥, 以便对信息进行对称加密</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Client请求HTTPS连接</span><br><span class="line"></span><br><span class="line">Server发送公钥</span><br><span class="line"></span><br><span class="line">Client用公钥对自己的密钥加密, 发送密文</span><br><span class="line"></span><br><span class="line">Server用私钥对密文解密, 获取Client的密钥, 此时Client和Server拥有同样的密钥, 可以进行对称加密</span><br></pre></td></tr></table></figure>
<ul>
<li>数字证书、数字签名</li>
</ul>
<p>具有风险, 因为公钥是暴露出来的，当公钥被中间人替换成自己的公钥发送给客户端，中间人就可以得到对称加密的密钥, 因此引入数字证书和签名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Client请求HTTPS连接</span><br><span class="line"></span><br><span class="line">Server发送公钥、数字证书、签名摘要</span><br><span class="line"></span><br><span class="line">Client开始查找操作系统中内置的证书发布机构CA, 判断证书是否合法, 若合法会用公钥对证书的签名进行摘要算法, 比对摘要是否相同. 最后用公钥对自己的密钥加密, 发送密文</span><br><span class="line"></span><br><span class="line">Server用私钥对密文解密, 获取Client的密钥, 此时Client和Server拥有同样的密钥, 可以进行对称加密</span><br></pre></td></tr></table></figure>
<ul>
<li>加密</li>
</ul>
<p>对称加密: 加密和解密使用同样的密钥, 如DES</p>
<p>非对称加密: 使用了公钥和私钥, 私钥不能外泄，而公钥则可以发给它人, 公钥加密后得用私钥解密, 如RSA</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A生成一对密钥并将公钥发给B</span><br><span class="line"></span><br><span class="line">B得到公钥后用该密钥对信息加密, 再发送给A</span><br><span class="line"></span><br><span class="line">A用密钥对密文进行解密</span><br></pre></td></tr></table></figure>
<p>HASH加密(摘要): 通过HASH算法将信息生成一段HASH值, HASH值无法还原成信息, 如MD5, SHA</p>
<ul>
<li>SSL层: 位于应用层和传输层之间, 利用身份验证, 数据验证等机制, 为基于TCP等可靠连接的应用层协议提供安全性保证</li>
</ul>
<ul>
<li>Ping</li>
</ul>
<p>用于测试两台主机之间的连通性. ICMP差错报告协议</p>
<ul>
<li>TCP/IP协议族</li>
</ul>
<p>网络层: IP、ICMP、ARP(IP地址转换为MAC地址)</p>
<p>传输层: TCP、UDP</p>
<p>应用层: DNS(使用UDP)、HTTP、FTP、SMTP</p>
<ul>
<li>交换机的工作原理(隔离冲突域)</li>
</ul>
<p>通过自学习算法建立转发表. 每收到一帧, 记下源地址和进入网桥的端口, 作为转发表的一项</p>
<p>若转发表中不存在帧的目的地址, 交换机会广播一个发现帧, 目的站收到后发送应答帧, 应答帧在返回的过程中记录沿途的交换机. 源交换机收到应答帧后, 就能得到转发的最佳端口</p>
<ul>
<li>路由器的工作原理(隔离广播域)</li>
</ul>
<p>最长前缀路由匹配</p>
<ul>
<li>IP分组</li>
</ul>
<p>因为数据比MTU(帧能承载的最大数据量)大, 因为得分组. 在第一个路由器处分装, 在目的主机重组</p>
<ul>
<li>抓包经历</li>
</ul>
<ul>
<li>默认网关</li>
</ul>
<p>默认路由器的IP地址</p>
<ul>
<li>无分类域间路由选择CIDR</li>
</ul>
<p>消除A、B、C类子网以及子网划分的概念</p>
<p>IP地址写成:  IP地址/网络前缀所占位数</p>
<ul>
<li>网络地址转换NAT</li>
</ul>
<p>将私有网络地址转换为公有地址, 对外隐藏内部IP地址, 使整个网络只要一个IP地址</p>
<ul>
<li><p>内部网关协议IGP</p>
<p>自治系统内的路由选择协议</p>
</li>
</ul>
<p>RIP: 使用距离向量算法, 路由表包含到所有结点的费用, 发送给相邻结点, 固定更新频率</p>
<p>OSPF: 使用链路状态算法, 路由表包含到相邻结点的费用, 发送给所有结点, 当路由表发生变化时更新</p>
<ul>
<li><p>外部网关协议EGP</p>
<p>自治系统间的路由选择协议, 包括BGP</p>
</li>
</ul>
<ul>
<li><p>DDOS攻击</p>
<p>分布式阻断服务</p>
</li>
</ul>
<p>  资源消耗类, 发送大量的攻击数据包，消耗网络带宽资源，影响正常用户的访问</p>
<p>​    服务消耗类, 发送大量的数据库查询, 消耗服务器资源</p>
<ul>
<li>Socket</li>
</ul>
<p>socket是在应用层和传输层之间的一个抽象层, 它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用</p>
<ul>
<li>cookie和session</li>
</ul>
<p>cookie: 存储在客户端, 单个cookie&lt;=4k, 一个站点最多保存20个cookie, 存储ASCII字符</p>
<p>session: 存储在服务器端, 存储任何类型数据</p>
<ul>
<li>分组转发</li>
</ul>
<p>(1) 如果在同一子网内, 直接得到目的IP地址, 进入(3)</p>
<p>(2) 如果在同一子网内, 分组从路由表得出下一跳路由器的IP地址后, 进入(3)</p>
<p>(3) 分组封装成帧进入链路层, 根据ARP协议, 将目的IP地址转换为MAC地址, 然后发送帧. </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/数据库学习/面经/数据库学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/数据库学习/面经/数据库学习/" itemprop="url">面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T15:12:16+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库学习/" itemprop="url" rel="index">
                    <span itemprop="name">数据库学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>存储过程</p>
<p>预编译的SQL语句, 可以多次调用</p>
</li>
</ul>
<ul>
<li><p>触发器</p>
<p>特殊的存储过程, 通过事件触发而被执行</p>
</li>
</ul>
<ul>
<li><p>游标</p>
<p>从数据表中提取出来的数据，以临时表的形式存放在内存中，在游标中有一个数据指针，在初始状态下指向的是首记录</p>
</li>
</ul>
<ul>
<li><p>视图</p>
<p>一张虚拟的表, 可以简化用户的操作, 视图只保存了sql语句，没有保存数据，每次使用视图时会去执行sql语句在它的基表中查询数据(Django的admin)</p>
</li>
</ul>
<ul>
<li><p>事务</p>
<p>绑定的一组SQL语句</p>
</li>
</ul>
<p>  特性ACID</p>
<p>  A: 原子性, 要么都执行, 要么都不执行</p>
<p>  C: 一致性, 事务前后数据总额一致</p>
<p>   I: 隔离性, 事务执行完之前不被看到过程</p>
<p>  D: 持久性, 提交后永久改变数据</p>
<ul>
<li><p>脏读、不可重复读、幻读</p>
<p>脏读: 事务A读取了事务B更新但未提交的数据，然后B回滚，那么A读取到的数据是脏数据</p>
</li>
</ul>
<p>  不可重复读: 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致</p>
<p>  幻读: 连续执行两次同样的SQL语句第二次的SQL语句可能返回之前不存在的行</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在事务1中，查询User表id为1的是用户否存在，如果不存在则插入一条id为1的数据。在事务1查询结束后，事务2往User表中插入了一条id为1的数据。此时事务1插入失败, 因为主键冲突</span><br></pre></td></tr></table></figure>
<p>不可重复读与幻读的区别: </p>
<p>不可重复读的重点是修改, 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了</p>
<p>幻读的重点在于新增或者删除, 同样的条件, 第1次和第2次读出来的记录数不一样</p>
<ul>
<li><p>数据库隔离级别</p>
<p>读未提交: 可以读到未提交的内容</p>
</li>
</ul>
<p>  不可重复读(读已提交): 事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致</p>
<p>  可重复读: MySQL默认级别, SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的</p>
<p>  串行化: 事务串行执行</p>
<table>
<thead>
<tr>
<th>事务隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>读未提交 read-uncommitted</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>不可重复读 read-committed</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>可重复读 repeatable-read     MySQL默认级别</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>串行化 serializable</td>
<td>否</td>
<td>否</td>
<td>否</td>
</tr>
</tbody>
</table>
<ul>
<li><p>MySQL存储引擎</p>
<p><strong>InnoDB</strong>：支持事务处理，支持外键，存储在硬盘, 索引是B+树</p>
<p><strong>MEMORY</strong>：所有的数据都在内存中，数据的处理速度快(默认Hash索引)，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低</p>
</li>
</ul>
<ul>
<li><p>查询语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select 列名 from 表名 where 列的条件 group by 分组方式 having 分组过滤方式 order by 按列排序</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>mysql和redis<br>redis： 内存型非关系数据库，数据保存在内存中，速度快, 不适合持久保存<br>mysql：关系型数据库，数据保存在磁盘中，检索的话，会有一定的Io操作，访问速度相对慢</li>
</ul>
<p>​    关系型数据库: 以二维表格保存, 事务支持, 复杂查询支持</p>
<p>​    非关系Nosql: 以键值对保存, 读写性能高, 易扩展</p>
<p>​    Redis缓存(小量数据)、MongoDB数据库(大量数据)</p>
<ul>
<li><p>索引</p>
<p>提高查询速度, 但更新时还要更新索引. 因此频繁查询使用索引, 频繁更新不用索引</p>
</li>
</ul>
<p>  底层实现: B+树, 每个结点中能存储多个值, 相比AVL树更宽更矮. 相比B-树, B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小, 一个盘块所能容纳的关键字数量也越多</p>
<p>  聚集: 索引顺序和数据存放的物理位置一样, 查找快因为符合条件的记录连续存放, 插入删除记录时需要对数据重新排序</p>
<p>  非聚集: </p>
<p>​    唯一索引: 两行的索引值不能相同, 允许有空值</p>
<p>​    主键索引: 特殊的唯一索引, 不允许有空值</p>
<ul>
<li><p>B+索引和Hash索引</p>
<p>Hash索引，等值查询效率高，不能进行范围查询, 无法排序, 发生哈希碰撞</p>
<p>B+索引, 查询要访问多个结点, 能范围查询, 叶结点有序</p>
</li>
</ul>
<ul>
<li><p>B+树</p>
<p>非叶结点不保存数据，只用来索引，所有数据都保存在叶子节点。<br>所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点依关键字的大小自小而大顺序链接</p>
</li>
</ul>
<ul>
<li><p>最左前缀原则</p>
<p>多列索引, 先看第一列, 在第一列满足条件的情况下再看第二列</p>
</li>
</ul>
<ul>
<li><p>SQL优化</p>
<p>使用索引</p>
<p>避免嵌套查询</p>
<p>多个字段等值查询时用联合索引</p>
</li>
</ul>
<ul>
<li><p>varchar和char</p>
<p>varchar: 用于字符串长度会变的</p>
<p>char: 用于字符串长度不变的</p>
</li>
</ul>
<ul>
<li><p>数据库连接池</p>
<p>维护一定数量的连接，减少创建连接的时间, 统一的管理</p>
</li>
</ul>
<ul>
<li><p>join</p>
<p>inner join: 返回左表和右表中都满足条件的行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select * from A JOIN B ON A.Aid=B.Bnameid</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  left join: 返回左表的全部行和右表满足条件的行, 如果左表的行在右表中没有匹配，那么这一行右表中对应数据用NULL代替</p>
<p>  right join同理</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from A Left JOIN B ON A.Aid=B.Bnameid</span><br></pre></td></tr></table></figure>
<p>  cross join: 笛卡尔积, 左表的每一条记录和右表的每一条记录生成一条记录</p>
<ul>
<li><p>悲观锁和乐观锁</p>
<p>悲观锁, 很悲观，每次去拿数据的时候都认为别人会修改，所以在做操作之前先上锁，这样别人想拿这个数据就会block直到它拿到锁。比如读锁，写锁等</p>
</li>
</ul>
<p>  乐观锁，很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，若被别人更新则回滚, 可以使用版本号等机制</p>
<ul>
<li><p>共享锁和互斥锁</p>
<p>共享锁, 即读锁, 其他人可以读, 但不能写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... LOCK IN SHARE MODE;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​    互斥锁, 即写锁, 其他不能读写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... FOR UPDATE;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数据库三范式</p>
<p>第一范式: 字段值不可再分</p>
</li>
</ul>
<p>  第二范式: 一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个人同时订几个房间，就会出来一个订单号多条数据，这样子联系人都是重复的，就会造成数据冗余。我们应该把他拆开来</span><br></pre></td></tr></table></figure>
<p>  第三范式: 确保每列都和主键列直接相关</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）</span><br><span class="line"></span><br><span class="line">应该拆开来，如下。</span><br><span class="line"></span><br><span class="line">（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数据库崩溃恢复</p>
<p>Undo log记录事务提交前的记录, 它可以用于回滚事务</p>
</li>
</ul>
<p>​    Redo log记录事务提交后的记录, 可以直接恢复到最新状态</p>
<ul>
<li><p>EXISTS和IN的区别</p>
<p>EXISTS: 先执行主查询语句，然后根据每一条记录进行子查询语句判定, 查询次数为主查询记录数</p>
</li>
</ul>
<p>​    IN: 先执行子查询，将子查询结果和主查询表做笛卡尔积，再选择符合条件的, 查询次数为两个表记录乘积</p>
<p>​    当子查询表较大时，使用EXISTS</p>
<ul>
<li>增、删、改、查</li>
</ul>
<p>创建表:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">	id INT PRIMARY KEY,		使用索引</span><br><span class="line">	name VARCHAR(20)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>增:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO Person(id, name) VALUES (2,&apos;Tom&apos;);</span><br></pre></td></tr></table></figure>
<p>删:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM Person WHERE id = 1;</span><br></pre></td></tr></table></figure>
<p>改:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE Person SET name = &apos;Tom&apos;, sex = &apos;male&apos; WHERE id = 1;</span><br></pre></td></tr></table></figure>
<p>查</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LIMIT 第一个数为开始的行数，第二个数为要检索的行数, 从第5行（实际表中的第六行）开始，显示5行</span><br><span class="line">SELECT cust_name  FROM customers  LIMIT 5, 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESC降序, ASC升序</span><br><span class="line">SELECT prod_name FROM products ORDER BY prod_price DESC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WHERE 的逻辑运算符有AND ,OR, NOT,IN</span><br><span class="line">SELECT *  FROM products WHERE vend_id = 1003 AND prod_price &lt;= 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">聚集函数</span><br><span class="line">AVG( ) 返回某列的平均值：SELECT AVG(prod_price) FROM products;</span><br><span class="line"></span><br><span class="line">COUNT( ) 返回某列的行数</span><br><span class="line"></span><br><span class="line">MAX( ) 返回某列的最大值</span><br><span class="line"></span><br><span class="line">MIN( ) 返回某列的最小值</span><br><span class="line"></span><br><span class="line">SUM( ) 返回某列值之和</span><br></pre></td></tr></table></figure>
<ul>
<li>防止SQL注入</li>
</ul>
<p>使用预编译绑定变量的SQL语句</p>
<p>使用正则表达式过滤传入的参数</p>
<ul>
<li>redis数据类型</li>
</ul>
<p>string: 最简单的key-value类型, 比如name: tom</p>
<p>hash: 当一个key对应多个value时, 使用hash, 是key-map的类型, 比如tom: {age: 10, sex: male}</p>
<p>list: </p>
<p>set: 自动去重 </p>
<p>sorted set: 自动排序的set</p>
<ul>
<li><p>redis持久化</p>
<p>rdb: 将数据库的快照保存在rdb文件中</p>
</li>
</ul>
<p>​    aof: 快照功能并不是完全持久化的, 当宕机, 已执行但未写入快照的数据将会丢失. 每当redis执行一个改变数据集的命令时，这个命令就会追加到aof文件的末尾。这样的话，当redis重新启动时，程序就会通过执行aof文件中的命令来达到重建数据集的目的</p>
<ul>
<li>redis事务</li>
</ul>
<p>mysql事务: 基于undo/redo日志实现. 能回滚, 将执行但未提交的事务回滚</p>
<p>redis事务: 基于COMMANDS队列. 若没开始事务, command将会被立即执行. 如果事务开启, command将会进入command队列, 调用EXCE 才会执行COMMANDS队列. 不能回滚, 但能将COMMANDS队列中的command丢弃</p>
<ul>
<li><p>redis索引实现</p>
<p>跳表, 即带多级索引的链表. 红黑树在查找区间元素的效率没有跳表高，其他操作时间复杂度一致</p>
</li>
</ul>
<p>对于有序的单链表, 假如链表中有 n 个元素，我们每两个节点建立一个索引，那么第 1 级索引的结点个数就是 n/2 ，第二级就是 n/4，第三级就是 n/8, 依次类推</p>
<p>跳表的插入: 从下而上, 逐层插入, 产生一个随机数，50%概率再向上扩展，否则就结束</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/操作系统学习/面经/操作系统学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/操作系统学习/面经/操作系统学习/" itemprop="url">面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T15:12:16+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统学习/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>并发和并行</li>
</ul>
<p>并发: 同一时间间隔</p>
<p>并行: 一起走, 同一时刻</p>
<ul>
<li>线程安全</li>
</ul>
<p>对于拥有共享数据的多线程并发执行, 使用同步机制保证各线程可以正确执行</p>
<ul>
<li>中断和异常</li>
</ul>
<p>中断(外中断): 来自CPU和主存外部的事件</p>
<p>异常(内中断、陷入), 比如溢出, 陷入指令</p>
<p>发生中断/异常, CPU会保持当前上下文(PC, PSW, 通用寄存器), 切换到内核态, 再执行中断处理程序</p>
<ul>
<li>临界区</li>
</ul>
<p>一段对共享资源的保护代码，该代码保护线程对共享资源的互斥访问。</p>
<ul>
<li>进程和线程</li>
</ul>
<p>进程: 资源分配的基本单位. </p>
<p>线程: 程序执行和调度的基本单位, 不拥有资源但可以共享进程的所有资源</p>
<p>协程: 它是比线程更加轻量级的存在，一个线程可以拥有多个协程. 它是一个在用户态下运行的特殊函数. 一个线程中的多个协程是串行运行的</p>
<p>僵尸进程: 指一个调用exit命令终止, 但是其父进程尚未对其进行善后处理的进程</p>
<ul>
<li>什么时候用进程, 什么时候用线程</li>
</ul>
<p>频繁创建: 用线程, 比如Web服务器, 每一个连接对应一个线程</p>
<p>频繁调度, 切换上下文: 用线程</p>
<p>更方便地共享数据: 线程</p>
<p>较多同步操作: 进程</p>
<ul>
<li>进程状态</li>
</ul>
<p>运行态</p>
<p>就绪态: 进程已获得资源, 等待CPU调度</p>
<p>阻塞态: 进程等待资源. 阻塞态只能转到就绪态</p>
<p>创建态</p>
<p>结束态</p>
<ul>
<li>进程通信</li>
</ul>
<p>管道: 本质是缓冲区文件, 属于半双工通信, 数据单向流动</p>
<p>共享存储: 对共享空间进行读/写</p>
<p>套接字Socket: 可用于不同的进程通信</p>
<p>信号机制: </p>
<ul>
<li><p>死锁</p>
<p>多个进程因竞争资源而造成互相等待, 若无外力作用，这些进程都将无法向前推进</p>
</li>
</ul>
<p>死锁条件:</p>
<p>​    互斥: 资源每次只能被一个进程使用</p>
<p>​    不剥夺: 进程所获得的资源在未使用完毕之前，不能被夺走</p>
<p>​    请求和保持: 进程已经获得资源，但又提出了新的资源请求</p>
<p>​    循环等待: 进程间形成首尾相接循环等待资源的关系</p>
<p>死锁预防:</p>
<p>​    破坏死锁四个条件之一</p>
<p>死锁避免: </p>
<p>​    系统对进程发出的资源申请进行动态检查(银行家算法),并根据检查结果决定是否分配资源,如果分配后系统可能发生死锁,则不予分配,否则予以分配</p>
<ul>
<li>程序运行过程</li>
</ul>
<p>预处理: 把include的头文件内容移到源文件中，处理宏定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.c -&gt; .i</span><br></pre></td></tr></table></figure>
<p>编译: 源代码编译成汇编文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.i -&gt; .s</span><br></pre></td></tr></table></figure>
<p>汇编: 汇编代码生成目标文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.s -&gt; .obj</span><br></pre></td></tr></table></figure>
<p>链接: 目标文件经过静态链接lib和动态链接dll生成可执行文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.obj -&gt; .exe</span><br></pre></td></tr></table></figure>
<ul>
<li>内存管理</li>
</ul>
<p>分页存储</p>
<p>​    把内存和进程划分成固定大小的块, 进程中的块称为页, 内存中的块成为页框. 每个进程一张页表</p>
<p>分段存储</p>
<p>​    把进程划分成大小不等的段, 提高程序的逻辑性. 每个进程一张段表</p>
<p>段页式存储</p>
<p>​    把进程划分成大小不等的段, 然后将每段分成大小相等的页</p>
<ul>
<li>内部碎片和外部碎片</li>
</ul>
<p>内部碎片: 已分配但因为太小不能利用的内存</p>
<p>外部碎片: 因为太小不能分配的内存</p>
<ul>
<li><p>进程调度算法</p>
<p>先来先服务FCFS: 从就绪队列中选中进入队列的进程</p>
</li>
</ul>
<p>  短作业优先SJF: 从就绪队列中选择运行时间最短的进程, 产生饥饿</p>
<p>  轮转调度法: 按时间片, 切换上下文浪费时间</p>
<p>  多级反馈队列: 设置多个队列, 第1级队列优先级最高, 优先级越高的队列时间片越小, 在每个队列中采用时间片轮转的方式运行</p>
<ul>
<li>页面置换算法</li>
</ul>
<p>最佳置换OPT: 置换未来最久不会使用的页面</p>
<p>先进先出置换FIFO: 会产生随着分配的物理块增多, 缺页次数增加的Belady异常</p>
<p>LRU: 置换最久未使用的, 使用双向链表 + map, 链表按访问时间排序, 链表头放最近访问的, 置换时从链表尾取出, map中存储key-链表中指针</p>
<p>get: 从map中获取, 并将map中指针放到链表头</p>
<p>put: 如果未满, 直接放入链表头, 并更新map; 若已满, 从链表尾中取出, 从map中删除链表尾的, 再将新的放入链表头, 更新map</p>
<p>​    </p>
<p>LFU: 置换总的使用次数最少的, 使用双向链表 + map, 统计每个页的总访问次数, </p>
<p>时钟置换NRU: 页附加使用位, 装入内存时置1. 要替换时查找使用位为0的页, 期间遇到1置0, 循环查找</p>
<p>改进时钟置换CLOCK:  附加使用位和修改位, 都置1. 先查找u=0, v=0. 若没有查找u=0, 期间遇到u=1置0, 循环后u都为0. 若还没有查找v=0</p>
<ul>
<li>工作集</li>
</ul>
<p>一段时间要访问的页的集合</p>
<ul>
<li>线程池</li>
</ul>
<p>为了避免一个程序需要大量创建线程与销毁线程的时间浪费, 使用线程池在初始的时候创建一些线程, 一般为CPU核心数的两倍, 放到就绪队列上</p>
<ul>
<li>大端法和小端法</li>
</ul>
<p>大端法: 先存储高位字节, 123456, 存储是123456</p>
<p>小端法: 先存储低位字节, 123456, 存储是563412</p>
<p>判断大端和小端:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">union Test &#123;</span><br><span class="line">    int a;</span><br><span class="line">    char b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line">t.a = 1;</span><br><span class="line">if (t.b == 1)</span><br><span class="line">	cout &lt;&lt; &quot;小端机器&quot; &lt;&lt; endl;</span><br><span class="line">else</span><br><span class="line">	cout &lt;&lt; &quot;大端机器&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<ul>
<li>bitmap</li>
</ul>
<p>用一个bit位来标记某个元素是否存在, 比如元素的大小[0, N - 1], 那么就用N bit的存储空间, 值为1代表元素存在, 值为0代表元素不存在</p>
<p>大量数据排序, 查找数据是否存在: 遍历数据, 存储在bitmap中</p>
<p>在大量数据中查找出重复数据: 用2个bitmap, 第一个表示是否存在, 第二个表示是否重复, 或用一个bip, 用2bit对应每个元素, 00代表不存在, 01代表存在, 10代表重复</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/python学习/面经/python学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/python学习/面经/python学习/" itemprop="url">面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T15:12:16+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python学习/" itemprop="url" rel="index">
                    <span itemprop="name">python学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>Python</p>
<p>非独立语言, 依赖解释器</p>
<p>动态语言(弱类型语言), 运行期间才确定数据类型</p>
<p>面向对象的语言</p>
</li>
</ul>
<ul>
<li><p>提高Python运行效率</p>
<p>使用生成器</p>
<p>循环代码优化</p>
<p>多线程并发执行</p>
<p>核心模块用Cython, PyPy. PyPy对纯Python兼容性好, Cython对Python + C</p>
</li>
</ul>
<ul>
<li><p>生成器</p>
<p>如果列表元素按照某种算法推算出来，那我们就可以在循环的过程中不断推算出后续的元素，这样就不必创建完整的list，从而节省大量的空间。</p>
</li>
</ul>
<p>  写法1:  把一个列表生成式的[]中括号改为()</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gene = (x*x for x in range(3))</span><br><span class="line"></span><br><span class="line">for i in gene:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>  写法2: yield相当于 return 一个值，并且记住这个返回的位置，下次迭代时，代码从yield的下一条语句开始执行</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fib(max):</span><br><span class="line">    n,a,b = 0,0,1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        yield b</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        n = n+1</span><br><span class="line">    return &apos;done&apos;</span><br><span class="line">    </span><br><span class="line">for i in fib(6):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<ul>
<li>可变数据类型: 修改值时直接在当前内存空间修改, List, Set, Dictionary</li>
<li>不可变数据类型: 不允许变量的值变化, 如果改变了变量的值，相当于是新建了一个对象, 对于相同的值的对象，在内存中则只有一个对象，Number, String, Tuple</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = 3</span><br><span class="line">b = 3</span><br><span class="line">id(a) == id(b)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Number</p>
<p>int, bool, float, complex (复数)</p>
</li>
</ul>
<ul>
<li><p>String</p>
<p>用单引号或双引号, 没有字符类型</p>
</li>
</ul>
<p>​    截取: [头下标 :  尾下标-1 :  步长], 左闭右开, 尾下标为负表示从右向左, -1表示倒数第2个</p>
<p>​    </p>
<p>​    字符与非字符不能直接连接, str(111) + ‘aaa’</p>
<p>​    替换字符串中的值, newstr = oldstr.replace(‘a’, ‘b’)    a替换b</p>
<ul>
<li><p>Tuple</p>
<p>当tuple只有1个元素时加逗号(1,)</p>
</li>
</ul>
<ul>
<li><p>List</p>
<p>添加元素: a.append(1)</p>
</li>
</ul>
<p>​    截取: [头下标 : 尾下标 - 1]</p>
<p>​    排序(从小到大)</p>
<p>​        list.sort(reverse = False), </p>
<p>​        list = sorted(list, reverse = False)</p>
<p>​        list = sorted(list, key = lambda x :  (x[‘name’], x[‘age’]), reverse = False)    # key指定先根据name进行排序, 再根据age排序</p>
<p>​    合并, list1.extend(list2)</p>
<ul>
<li><p>list与string转换</p>
<p>list = str.split(‘ ‘)</p>
<p>str = ‘’.join(list)</p>
</li>
</ul>
<ul>
<li><p>Set</p>
<p>自动去掉重复元素</p>
</li>
</ul>
<p>​    交集: a &amp; b</p>
<p>​    并集: a | b</p>
<p>​    差集: a - b</p>
<ul>
<li>Dicitionary</li>
</ul>
<p>​    添加元素: dict[‘name’] = ‘tom’</p>
<p>​    删除元素: del dict[‘name’]</p>
<p>​    长度: len(dict)</p>
<p>​    返回key和value的迭代器: list(dict.keys()), list(dict.values())</p>
<p>​    按键排序, sorted(dict.items(), key = lambda x:x[0])</p>
<p>​    合并dict1, dict2: dict1.update(dict2)</p>
<ul>
<li><p>模块</p>
<p>.py文件</p>
</li>
</ul>
<p>  将整个模块导入，import somemodule</p>
<p>  从某个模块中导入函数,    from somemodule import firstfunc, secondfunc, thirdfunc</p>
<p>  将某个模块中的全部函数导入，from somemodule import *</p>
<ul>
<li>del 删除对象</li>
</ul>
<ul>
<li>数值的除法包含两个运算符：<strong>/</strong> 返回一个浮点数，<strong>//</strong> 返回一个整数</li>
</ul>
<ul>
<li><p>布尔运算符</p>
<p>and, or, not</p>
<p>x and y和 x or y 若是短路求值, 会直接返回y</p>
</li>
</ul>
<ul>
<li><p>GIL</p>
<p>GIL是Global Interpreter Lock，即全局解释锁，保证了了同一时刻只有一个线程被CPU调度, 因此Python中将多线程设计的时候只考虑了单核CPU, 设计成了并发执行, 没有实现并行执行 </p>
</li>
</ul>
<ul>
<li><p>print</p>
<p>print(‘{} {} {}’.format(a, b, c))</p>
<p>print(‘%d’ % a)</p>
<p>python2可以用print a b</p>
</li>
</ul>
<ul>
<li><p>range</p>
<p>左闭右开, [头下标 : 尾下标 - 1 : 步长], 返回值为迭代器, 可以转成list</p>
</li>
</ul>
<ul>
<li><p>pass</p>
<p>占位符, 不做任何事</p>
</li>
</ul>
<ul>
<li><p>三元运算符</p>
<p>min = x if condition else y</p>
</li>
</ul>
<ul>
<li><p>fun(*args, **kwargs)</p>
<p>*args表示传不定量的非键值对参数, fun(1, 2, 3)</p>
<p>**kwargs表示传不定量的键值对参数, fun(name=’tom’, age=10) </p>
</li>
</ul>
<ul>
<li><p>拷贝</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [1, [2, 3]]</span><br><span class="line">b = a, b引用a</span><br><span class="line">c = copy.copy(a), 浅拷贝, 外层是拷贝的, 内层是引用</span><br><span class="line">d = copy.deepcoyp(a), 深拷贝, 和a没有任何联系</span><br><span class="line"></span><br><span class="line">a.append(4) 	</span><br><span class="line">a[1].append(5)	c也会影响</span><br></pre></td></tr></table></figure>
</li>
<li><p>闭包</p>
<p>不改变函数代码的情况下, 使用自由变量的函数</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def outer_func():</span><br><span class="line">    a = &apos;Hello&apos;</span><br><span class="line">    def inner_func(name):</span><br><span class="line">        print(&apos;&#123;&#125; &#123;&#125;&apos;.format(a, name))</span><br><span class="line">    return inner_func</span><br><span class="line"></span><br><span class="line">func = outer_func()</span><br><span class="line">func(&apos;World&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>装饰器</p>
<p>python支持函数作为参数传递</p>
</li>
</ul>
<p>  装饰器本身是一个函数, 目的是在不改变待装饰函数代码的情况下, 增加新功能. </p>
<p>  @将被装饰函数传递给装饰器函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def dec(f):</span><br><span class="line">	n = 3</span><br><span class="line">	def wrappaer(*args, **kwargs):</span><br><span class="line">		return f(*args, **kwargs) * 3</span><br><span class="line">	return wrapper</span><br><span class="line">	</span><br><span class="line">@dec</span><br><span class="line">def foo(n):</span><br><span class="line">	return n * 2</span><br><span class="line">	</span><br><span class="line">foo(2)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>lambda</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sum = lambda arg1, arg2: arg1 + arg2</span><br><span class="line">print(sum(1, 2))</span><br></pre></td></tr></table></figure>
</li>
<li><p>类</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyClass:</span><br><span class="line"></span><br><span class="line">    &apos;&apos;&apos;公有变量&apos;&apos;&apos;</span><br><span class="line">    data = 0</span><br><span class="line"></span><br><span class="line">    &apos;&apos;&apos;私有变量&apos;&apos;&apos;</span><br><span class="line">    __data = 0</span><br><span class="line"></span><br><span class="line">    &apos;&apos;&apos;函数第一个参数必须为self&apos;&apos;&apos;</span><br><span class="line">    def printData(self):</span><br><span class="line">        print(self.__data)</span><br><span class="line"></span><br><span class="line">    &apos;&apos;&apos;私有方法&apos;&apos;&apos;</span><br><span class="line">    def __func():</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    &apos;&apos;&apos;构造函数&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, newdata):</span><br><span class="line">        self.__data = newdata</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = MyClass(1)</span><br><span class="line">x.printData()</span><br></pre></td></tr></table></figure>
<ul>
<li>继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SubClass(MyClass):</span><br><span class="line"></span><br><span class="line">    def __init__(self, newdata):</span><br><span class="line">        #调用父类的构函</span><br><span class="line">        MyClass.__init__(self, newdata)</span><br></pre></td></tr></table></figure>
<ul>
<li>__new__和__init__区别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class  User:</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;new&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        print(&quot;init&quot;)</span><br></pre></td></tr></table></figure>
<p>new: 参数是cls, 创建实例, 会自动调用init</p>
<p>init: 参数是self, 初始化</p>
<h4 id="通过一个类创建对象时，会先自动调用new方法，开辟一个内存空间给实例化对象，然后return这个内存空间给init方法，init方法再对这个内存空间进行初始化操作"><a href="#通过一个类创建对象时，会先自动调用new方法，开辟一个内存空间给实例化对象，然后return这个内存空间给init方法，init方法再对这个内存空间进行初始化操作" class="headerlink" title="通过一个类创建对象时，会先自动调用new方法，开辟一个内存空间给实例化对象，然后return这个内存空间给init方法，init方法再对这个内存空间进行初始化操作"></a>通过一个类创建对象时，会先自动调用new方法，开辟一个内存空间给实例化对象，然后return这个内存空间给init方法，init方法再对这个内存空间进行初始化操作</h4><ul>
<li><p>with</p>
<p>适用于对资源进行访问的场合, 简化try except finally的流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">with open(&quot;/tmp/foo.txt&quot;) as file:</span><br><span class="line">    data = file.read()</span><br><span class="line">    </span><br><span class="line">代替</span><br><span class="line">try:</span><br><span class="line">    f = open(&apos;xxx&apos;)</span><br><span class="line">except:</span><br><span class="line">    print &apos;fail to open&apos;</span><br><span class="line">    exit(-1)</span><br><span class="line">try:</span><br><span class="line">    do something</span><br><span class="line">except:</span><br><span class="line">    do something</span><br><span class="line">finally:</span><br><span class="line">     f.close()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>map </p>
<p>对list操作, 第1个参数是函数, 第二个参数是list, 返回值要转换成list</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(map(lambda x: x ** 2, [1, 2, 3]))</span><br></pre></td></tr></table></figure>
<ul>
<li><p>列表推导式</p>
<p>过滤list中符合条件的值</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = [i for i in [1, 2, 3] if i &gt; 2]</span><br></pre></td></tr></table></figure>
<ul>
<li>字典推导式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;k: random.randint(4, 9) for k in [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>filter</p>
<p>过滤list中符合条件的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = filter(lambda i : TRUE if i &gt; 2 else FALSE, [1, 2, 3])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>随机数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">整数</span><br><span class="line">result = random.randint(10, 20)</span><br><span class="line"></span><br><span class="line">小数</span><br><span class="line">res = random.random()	生成0~1的小数</span><br></pre></td></tr></table></figure>
<ul>
<li>避免转义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(r&apos;\na&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>断言</p>
<p>断言失败, 程序报错</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(a &gt; 1)</span><br></pre></td></tr></table></figure>
<ul>
<li>正则</li>
</ul>
<p>match: 检测字符串开头是否匹配, 匹配后返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">re.match(正则式, 字符串, 匹配方式)</span><br><span class="line"></span><br><span class="line">print(re.match(&quot;func&quot;, &quot;function&quot;).group())</span><br></pre></td></tr></table></figure>
<p>search : 在整个字符串中检测, 找到第一个匹配后返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(re.search(&quot;tion&quot;, &quot;function&quot;).group())</span><br></pre></td></tr></table></figure>
<p>findall: 在整个字符串中检测, 返回list</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">line = &quot;Cats are smarter than dogs&quot;</span><br><span class="line"></span><br><span class="line">findObj = re.findall( r&apos;(.*) are .*&apos;, line, re.M|re.I)</span><br><span class="line"></span><br><span class="line">当有括号时, 返回括号中的匹配内容; 无括号时, 返回整条匹配的内容</span><br></pre></td></tr></table></figure>
<p>compile: 将正则表达式编译成一个对象，加快速度，并重复使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kk = re.compile(r&apos;(.*) are (.*?) .*&apos;)</span><br><span class="line">kk.findall(line)</span><br></pre></td></tr></table></figure>
<p>（.*）贪婪匹配，会把满足正则的尽可能多的往后匹配</p>
<p>（.*?）非贪婪匹配，会把满足正则的尽可能少匹配</p>
<p>sub 替换字符串中匹配的项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">re.sub(正则式, 替换字符串, 字符串)</span><br><span class="line"></span><br><span class="line">re.sub(r&apos;\d+&apos;, &apos;100&apos;, &apos;Tom is 10&apos;)</span><br></pre></td></tr></table></figure>
<p>split分割字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.split(r&apos; |.&apos;, &apos;Tom is .a.&apos;)	# |表示或, 根据空格和.进行分割</span><br></pre></td></tr></table></figure>
<ul>
<li>时间戳</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datetime.datetime.now().strftime(&apos;%Y-%m-%d %H:%M:%S&apos;)</span><br></pre></td></tr></table></figure>
<ul>
<li>异常</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    raise ValueError	# 主动抛出异常, 后面代码不能执行</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">except ValueError:	# 发生特定异常</span><br><span class="line">    </span><br><span class="line">except:		# 发生任意异常</span><br><span class="line"> </span><br><span class="line">else:		# 不发生异常</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line"></span><br><span class="line">except ValueError:</span><br><span class="line"></span><br><span class="line">finally:	# 不管是否发生异常都执行</span><br></pre></td></tr></table></figure>
<ul>
<li><p>zip</p>
<p>以多个list作为参数, 返回元组list</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip([1, 2], [3, 4])		# [(1, 3), (2, 4)]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>单例模式</p>
<p>类只有一个实例对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    __instance = None </span><br><span class="line"></span><br><span class="line">    def __new__(cls, age, name):</span><br><span class="line">        if not cls.__instance:</span><br><span class="line">            cls.__instance = object.__new__(cls)</span><br><span class="line">        return cls.__instance</span><br><span class="line"></span><br><span class="line">    def __init__(self, age, name):</span><br><span class="line">        self.age = age </span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Singleton(18, &apos;tom&apos;)</span><br><span class="line">b = Singleton(10, &apos;sss&apos;)</span><br><span class="line"></span><br><span class="line">print(a.age)</span><br></pre></td></tr></table></figure>
</li>
<li><p>any和all</p>
<p>any():只要迭代器中有一个元素为真就为真</p>
<p>all():迭代器中所有的判断项返回都是真，结果才为真</p>
</li>
</ul>
<p>​    0，空字符串，空列表、空字典、空元组、None, False都当作假</p>
<ul>
<li><p>魔法方法</p>
<p>用双下划线包围的函数</p>
</li>
</ul>
<p>​    删除对象时, 自动调用__del__()</p>
<ul>
<li><p>python垃圾回收机制</p>
<p>以引用计数为主，标记-清除和分代清除为辅, 标记-清除和分代回收主要是为了处理循环引用</p>
</li>
</ul>
<ul>
<li>引用计数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python中每个东西都是对象</span><br><span class="line"></span><br><span class="line">typedef struct_object &#123;</span><br><span class="line">	int ob_refcnt;</span><br><span class="line">	struct_typeobject *ob_type;</span><br><span class="line">&#125;PyObject;</span><br><span class="line"></span><br><span class="line">ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少</span><br></pre></td></tr></table></figure>
<ul>
<li><p>循环引用</p>
<p>只会出现在“内部存在可以对其他对象引用的对象”，比如：list，class等</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2]</span><br><span class="line">b = [3,4]</span><br><span class="line">a.append(b)</span><br><span class="line">b.append(a)</span><br><span class="line"></span><br><span class="line">del a	此时a的引用计数为1, 不能释放</span><br></pre></td></tr></table></figure>
<ul>
<li><p>标记-清除</p>
<p>标记对象（垃圾检测），然后清除垃圾（垃圾回收）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始所有对象标记为白色，并确定根节点对象（这些对象是不会被删除），标记它们为黑色（表示对象有效）。将被引用的对象标记为灰色（表示还没检查），检查完灰色对象引用的对象后，将灰色标记为黑色。重复直到不存在灰色节点为止。最后白色结点都是需要清除的对象。</span><br></pre></td></tr></table></figure>
</li>
<li><p>分代回收</p>
<p>分代技术是一种典型的以空间换时间的技术，这也正是java里的关键技术。这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分代就是将回收对象分成数个代，每个代就是一个链表</span><br><span class="line"></span><br><span class="line">python里一共有三代，每个代的threshold值表示该代最多容纳对象的个数. 0代触发将清理所有三代，1代触发会清理1,2代，2代触发后只会清理自己</span><br></pre></td></tr></table></figure>
<ul>
<li><p>函数传参</p>
<p>参数传引用. 对于不可变类型，因变量不能修改，所以运算不会影响到变量自身；而对于可变类型，函数体运算可能会更改传入的参数变量。</p>
</li>
</ul>
<ul>
<li><p>r, w, a</p>
<p>r: 文件必须存在, 只读</p>
<p>w: 文件若不存在会创建, 只写, 覆盖写</p>
<p>a: 文件若不存在会创建, 只写, 追加写</p>
<p>r+: 文件必须存在, 读写</p>
<p>w+: 文件若不存在会创建, 读写, 覆盖写</p>
<p>a+: 文件若不存在会创建, 读写, 追加写</p>
</li>
</ul>
<ul>
<li>序列化, 反序列化</li>
</ul>
<p>序列化: 将内存中对象转换成二进制序列, 以便持久存储、传输</p>
<p>使用Pickle模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = 123</span><br><span class="line">with open(filename,&apos;wb&apos;) as f:</span><br><span class="line">	pickle.dump(a,f)</span><br><span class="line"></span><br><span class="line">with open(filename,&apos;wb&apos;) as f:</span><br><span class="line">	a = pickle.load(f)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/linux学习/面经/linux学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/linux学习/面经/linux学习/" itemprop="url">面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T15:12:16+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux学习/" itemprop="url" rel="index">
                    <span itemprop="name">linux学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>常用linux命令</li>
</ul>
<p>ls, cd, touch(创建文件), cat(读取文件并输出), rm, cp(复制文件到指定目录), clear(清屏)</p>
<ul>
<li><p>查看进程名为xx的进程信息</p>
<p>ps -ef | grep xx</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps: 进程查看命令</span><br><span class="line">grep: 使用正则表达式搜索文本</span><br><span class="line"></span><br><span class="line">-e: 显示所有进程</span><br><span class="line">-f: 全格式</span><br></pre></td></tr></table></figure>
<ul>
<li><p>杀掉指定pid的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找文件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find 指定目录 文件名</span><br></pre></td></tr></table></figure>
<ul>
<li>查看内存和负载</li>
</ul>
<p>top</p>
<ul>
<li>查询进程名为xx的进程网络方面的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat xx</span><br></pre></td></tr></table></figure>
<ul>
<li>Linux的I/O模型</li>
</ul>
<p>进程 - 缓冲区 - IO设备</p>
<p>阻塞IO: 进程调用recvfrom后，若缓冲区数据未准备好, 进程被阻塞, IO处理完后返回进程. </p>
<p>非阻塞IO: 进程调用recvfrom后，如果缓冲区数据未准备好，不阻塞直接返回, 因此进程需要多次轮询</p>
<p>IO复用: 是阻塞的, 当某块数据准备就绪,  通知进程调用recvfrom</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将各个IO句柄注册到linux提供的IO复用函数上(select,poll或者epoll), 如果某个句柄的IO数据就绪,则函数返回通知io ready, 调用者进行后续的read write操作</span><br></pre></td></tr></table></figure>
<p>信号驱动IO: 进程发起IO调用后，建立信号处理程序后直接返回. 当有缓冲区数据准备好后, 给进程返回一个信号量, 通知它调用recvfrom</p>
<p>异步IO: 上述的四个都是同步IO, 同步IO需要进程自己负责读写. 异步IO在进程发起一个IO操作后，进程返回, 由内核处理完IO后再通知进程</p>
<ul>
<li>同步和异步、阻塞和非阻塞</li>
</ul>
<p>阻塞和非阻塞: 当资源未准备好时, 是否需要等待</p>
<p>同步和异步: 进程间执行的顺序</p>
<ul>
<li>IO复用的实现</li>
</ul>
<p>select: 通过遍历文件描述符来获取已经就绪的文件, 文件描述符有最大数量限制</p>
<p>poll: 通过遍历文件描述符来获取已经就绪的文件, 没有最大数量限制</p>
<p>epoll: 因为大部分时候只有少数socket处于活跃状态, 因此遍历所有文件描述符开销大. 不再需要遍历文件描述符, 而是监听每个文件描述符, 一旦它就绪, 进程会得到通知</p>
<ul>
<li>fork</li>
</ul>
<p>产生一个新的进程</p>
<p>在父进程中，fork返回新创建子进程的进程ID；<br>在子进程中，fork返回0；<br>若出现错误，fork返回一个负值；</p>
<ul>
<li>异步实现方式</li>
</ul>
<p>回调: 完成后执行回调函数</p>
<p>事件监听: 基于事件驱动</p>
<ul>
<li>线程间实现同步</li>
</ul>
<p>锁: </p>
<p>信号量: 信号量是一个计数器，其值为可用资源数量。它支持两个操作：执行P操作时, 信号量–，当信号量 &gt; 0, 直接获取资源; 当信号量 &lt; 0, 请求该信号量的线程会被挂起；而执行v操作时，会叫醒一个在该信号量上面等待的线程, 信号量++</p>
<p>消息传递: 双方经过互相收发消息来实现同步. 接收消息的线程, 只有接收到消息才能继续执行</p>
<ul>
<li>设计模式</li>
</ul>
<p>单例模式</p>
<p>工厂模式: 每次类都需要一个工厂</p>
<p>抽象工厂模式: 创建一系列类的工厂</p>
<p>适配器模式: 把一个类的接口变换成客户端所期待的另一种接口</p>
<p>观察者模式</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/django学习/面经/django学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/django学习/面经/django学习/" itemprop="url">面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T15:12:16+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/django学习/" itemprop="url" rel="index">
                    <span itemprop="name">django学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>ORM</li>
</ul>
<p>Object-Relation Mapping，意为对象-关系映射. 实现了数据模型与数据库的解耦. 无需关心程序底层使用的是MySQL、Oracle、sqlite….，如果数据库迁移，只需要更换Django的数据库引擎即可</p>
<ul>
<li>函数视图FBV、类视图CBV</li>
</ul>
<p>函数视图: 一个路径的所有不同HTTP请求方法写在一个函数中, 用if判断请求类型, 代码的复用性比较差</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def register(request):</span><br><span class="line">	if request.method == &apos;GET&apos;:</span><br><span class="line">	</span><br><span class="line">	else:</span><br></pre></td></tr></table></figure>
<p>类视图: 定义一个类, 一个路径的不同请求方法用不同的函数判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class RegisterView(View):</span><br><span class="line">	def get(self, request):</span><br><span class="line">	</span><br><span class="line">	def post(self, request):</span><br></pre></td></tr></table></figure>
<ul>
<li>中间件</li>
</ul>
<p>帮助我们在视图函数执行之前和执行之后做一些额外的操作. </p>
<p>HTTP请求流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. HTTP请求-&gt;HTTPRequest对象</span><br><span class="line">2. HTTPRequest对象-&gt;Request中间件. 若中间件返回Response, 执行5, 否则根据URL确定View</span><br><span class="line">3. Request中间件-&gt;View中间件, 若中间件返回Response, 否则执行模板中间件</span><br><span class="line">4. View中间件-&gt;Template中间件</span><br><span class="line">5. Response中间件</span><br><span class="line">6. 这个过程中如果引发了异常并抛出，会被Exception中间件处理器进行处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">process_request、process_view、process_template、process_response、process_exception</span><br></pre></td></tr></table></figure>
<ul>
<li>get, filter</li>
</ul>
<p>get返回一个匹配的结果, 如果满足条件的数据有多条会抛出异常</p>
<p>filter返回匹配结果的列表</p>
<ul>
<li>Session原理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">用户登录:</span><br><span class="line">	1. 服务器生成一个JSON&#123;&quot;sessionid&quot;: 随机字符串&#125;, 并保存到服务器的数据库中</span><br><span class="line">	2. 生成的JSON通过cookie返回给前端, 前端从cookie中获取到随机字符串</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">用户访问:</span><br><span class="line">	1. 在发送的请求头中设置cookie, 并将&#123;&quot;sessionid&quot;: 随机字符串&#125;放入cookie中. 服务器凭借该随机字符串, 在服务器的数据库中找到对应的条目, 再查看login</span><br><span class="line">	2. 根据session[&apos;login&apos;]判断是否登录</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">用户退出:</span><br><span class="line">	1. 服务器在数据库中删除对应条目</span><br></pre></td></tr></table></figure>
<ul>
<li>Session的弊端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 当一个用户, 在多台电脑时. 当用户在电脑A登录, 返回的sessionid保存在电脑A; 若用户要在电脑B登录, 得重新登录</span><br></pre></td></tr></table></figure>
<ul>
<li>csrf跨站请求伪造</li>
</ul>
<p>利用的是网站对用户网页浏览器的信任(cookie), 欺骗用户在已登录的Web上执行非本意的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">		①用户正常登录A银行网站,</span><br><span class="line"></span><br><span class="line">        ②A网站返回cookie信息给用户,浏览器保存cookie信息</span><br><span class="line"></span><br><span class="line">        ③在A网站没有退出登录的情况下(或者说cookie信息没过期), 登录了恶意网站B</span><br><span class="line"></span><br><span class="line">        ④恶意网站B,提前准备好转账表单或者其它请求 ,将其隐藏. 把提交到A网站的按钮设置为一个&quot;领取优惠券&quot;的图片链接.用户 点击链接</span><br><span class="line"></span><br><span class="line">        ⑤在用户主观未知的情况下,访问A网站,此时浏览器会自动携带cookie信息</span><br><span class="line"></span><br><span class="line">        ⑥A网站识别到cookie信息,默认为是用户本人做出的请求,根据请求做出相应的操作.</span><br><span class="line"></span><br><span class="line">        ⑦用户收到损失.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">防范原理:</span><br><span class="line">	登录时生成一个csrftoken放在cookie中，前端从cookie中取出该csrftoken并保存. </span><br><span class="line">	当用户再次向服务器发送请求时, 服务器会对比cookie和前端发送的请求头中的csrftoken, 若一样证明是用户操作.</span><br><span class="line">    对于hacker, 即使他获取了cookie, 但是他无法从cookie中取出csrftoken(加密), 因此他不能在请求中附带上csrftoken</span><br></pre></td></tr></table></figure>
<ul>
<li>单元测试</li>
</ul>
<p>用断言判断是否相等. 会创建一个模拟数据库, 在测试完后删除该数据库</p>
<ul>
<li>负载均衡</li>
</ul>
<p>访问请求分摊到多台服务器</p>
<ul>
<li>代理服务器</li>
</ul>
<p>位于客户端和服务器端之间的服务器</p>
<p>正向代理: 代理服务器为客户端服务. 客户端向代理服务器发送请求, 代理服务器向服务器发出请求, 获取资源后再发送给客户端</p>
<p>反向代理: 由于单个服务器的处理客户端请求能力有一个极限, 可以使用多个服务器来共同分担用户请求. 服务器端接受到客户端的请求后, 代理会把请求分发给不同的服务器进行处理, 然后再将服务器的响应结果反馈给客户端</p>
<ul>
<li>Restful API</li>
</ul>
<p>url用名词, 小写字母, 不要加文件后缀, url最后不要加/</p>
<p>用恰当的http方法</p>
<ul>
<li>Django和Flask</li>
</ul>
<p>Django: 较大较全面</p>
<p>Flask: 轻量级框架</p>
<ul>
<li>MTV</li>
</ul>
<p>M: model, 数据库相关</p>
<p>T: template, 将数据嵌入HTML页面</p>
<p>V: view, 逻辑处理</p>
<ul>
<li>wsgi, uwsgi</li>
</ul>
<p>wsgi: 一套协议。用于接收用户请求并将请求封装后交给web框架</p>
<p>uwsgi: Web服务器，它实现了wsgi、http等协议</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/c-学习/面经/c++学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/c-学习/面经/c++学习/" itemprop="url">面经</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-08T15:12:16+08:00">
                2020-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c-学习/" itemprop="url" rel="index">
                    <span itemprop="name">c++学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>C和C++区别</p>
<p>C: 面向过程, 内存使用用malloc和free</p>
<p>C++: 面向对象, 内存使用用new和delete, 有引用, 类的概念</p>
</li>
</ul>
<ul>
<li><p>面向对象</p>
<p>基于对象和类的软件开发思想</p>
</li>
</ul>
<ul>
<li>特性: 封装、继承、多态</li>
</ul>
<ul>
<li><p>多态</p>
<p>父类指针指向子类的对象, 使父对象就可以根据当前赋值给它的子对象的特性, 以不同的方式运作</p>
</li>
</ul>
<p>​    静态多态: 通过重载和模板技术实现，在编译的时候确定</p>
<p>​    动态多态: 通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。</p>
<ul>
<li><p>构造函数、析构函数调用顺序</p>
<p>构造: 父类-&gt;子类</p>
</li>
</ul>
<p>​    析构: 子类-&gt;父类</p>
<ul>
<li><p>友元</p>
<p>使友元函数、友元类能访问私有成员变量</p>
</li>
</ul>
<ul>
<li><p>final</p>
<p>禁止继承 class Father final{}</p>
</li>
</ul>
<p>  禁止重写 virtual void func() final;</p>
<ul>
<li><p>const</p>
<p>在编译期间完成, 使用常数直接替换掉此变量</p>
</li>
</ul>
<ul>
<li><p>存储类型</p>
<p>栈区：局部变量</p>
<p>堆区：由程序员自己申请 new malloc</p>
<p>全局区：静态变量和全局变量</p>
<p>常量区：常量字符串等</p>
</li>
</ul>
<ul>
<li><p>指针和引用的区别</p>
<p>指针: 保存对象地址, </p>
<p>对象: 保存对象别名, 定义时必须初始化, 必须从一而终</p>
</li>
</ul>
<ul>
<li><p>new和malloc的区别</p>
<p>new: 运算符, 根据数据类型分配空间, 返回对象指针, 会调用构造函数</p>
<p>malloc: 库函数, 根据字节大小分配空间, 返回void*, 不调用构造函数</p>
</li>
</ul>
<ul>
<li><p>volatile</p>
<p>CPU会优先访问内存中数据在寄存器的副本, 但当内存中的数据变换时, 寄存器还保留着原来的结果. volatile能告诉CPU去内存读取数据</p>
</li>
</ul>
<ul>
<li><p>static</p>
<p>在全局数据区分配空间, 而不是在栈中</p>
</li>
</ul>
<p>  修饰全局变量, 变量在该文件全局可见, 但不被其他文件所见(与全局变量不同)</p>
<p>  修饰局部变量, 每次调用当前函数, static变量会保存</p>
<p>  修饰函数, 函数在该文件全局可见, 但不被其他文件所见</p>
<p>  修饰成员变量, 变量被类的所有对象共享</p>
<p>  修饰成员函数, 函数被类的所有对象共享, 只能访问静态成员变量和函数, 没有this指针, 因此不会用const和volatile修饰</p>
<ul>
<li><p>extern</p>
<p>声明一个外部变量</p>
</li>
</ul>
<p>  extern c: 实现C++代码调用C语言代码. C++支持函数重载, 而C并不支持函数重载</p>
<ul>
<li><p>const</p>
<p>const int *</p>
<p>int const *</p>
<p>int* const </p>
</li>
</ul>
<p>  修饰成员变量, 必须在构造函数初始化, 只能被const成员函数调用</p>
<p>  修饰成员函数, 函数不应该修改成员变量</p>
<ul>
<li><p>define</p>
<p>宏替换, 预处理器处理</p>
</li>
</ul>
<ul>
<li><p>inline</p>
<p>解决频繁调用函数会消耗大量内存空间, 编译时展开</p>
</li>
</ul>
<ul>
<li><p>构造和析构函数中的异常</p>
<p>构造函数可以, 析构不可以抛出异常</p>
</li>
</ul>
<p>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题</p>
<ul>
<li><p>野指针</p>
<p>指针未初始化</p>
<p>delete指针未置为NULL</p>
</li>
</ul>
<ul>
<li><p>内存泄漏</p>
<p>申请的内存没有释放</p>
</li>
</ul>
<p>内存泄漏情况:</p>
<p>​    new后没delete</p>
<p>​    没清除嵌套指针, int**</p>
<p>​    当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露</p>
<p>​    </p>
<p>内存泄漏检测方法:</p>
<p>​    对象计数, 在对象构造时计数++，析构时–-，每隔一段时间打印对象的数量</p>
<p>​    重载new/delete，记录分配点（甚至是调用堆栈），定期打印</p>
<ul>
<li><p>智能指针</p>
<p>C++没有自动内存回收机制, 智能指针会自动调用析构函数，析构函数会自动释放资源</p>
</li>
</ul>
<p>​    包括auto_ptr, shared_ptr, weak_ptr, unique_ptr</p>
<p>​    用法: auto_ptr\&lt;MyClass> obj(new MyClass(“123”))</p>
<p>​    auto_ptr被unique_ptr取代, 无法两个unique_ptr指向同一个对象</p>
<p>​    shared_ptr, 对象可被多个指针共享</p>
<p>​    weak_ptr是用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放. 把shaerd_ptr赋成</p>
<ul>
<li><p>c++11特性</p>
<p>nullptr代替NULL，为了区分NULL和0</p>
<p>自动类型推导, auto和decltype, decltype解决auto只能对变量进行推导</p>
<p>迭代器</p>
<p>vector&lt;vector&lt;int>&gt;</p>
</li>
</ul>
<ul>
<li><p>字节对齐的原则</p>
<p>struct:</p>
<p>变量存储的起始位置是该变量大小的整数倍；</p>
<p>结构体总的大小是其最大元素的整数倍</p>
</li>
</ul>
<p>  如果用pragma pack(n)更改对齐字节数 ，取n和变量自身大小较小的一个, 变量存储的起始位置是其整数倍。</p>
<p>​    union: 多个变量公用一个空间, 节省空间</p>
<p>​        共用体总的大小是其最大元素的整数倍</p>
<p>​        能整除所有元素</p>
<ul>
<li>空结构体sizeof为1</li>
</ul>
<ul>
<li><p>结构体和类的区别</p>
<p>结构体: 默认继承方式public, 默认访问方式public</p>
</li>
</ul>
<p>​    类: 默认继承方式private, 默认访问方式private</p>
<ul>
<li><p>拷贝构造函数参数为什么要引用</p>
<p>不然在调用拷贝构造函数时，创建形参临时变量又会调用拷贝构造函数，会引起无限递归调用</p>
</li>
</ul>
<ul>
<li><p>静态链接与动态链接</p>
<p>静态链接: 编译链接时直接将需要的执行代码拷贝到调用处，优点就是不需要依赖库</p>
</li>
</ul>
<p>​    动态链接: 程序在运行到指定的代码时，去执行已经加载的动态库。优点是多个程序可以共享同一段代码</p>
<ul>
<li><p>重载和重写</p>
<p>重载: 函数名相同, 参数不同, 不关心返回值</p>
</li>
</ul>
<p>​    重写(覆盖): 子类重新定义父类的虚函数</p>
<p>​    隐藏: 子类定义和父类相同函数, 参数不同或参数相同没有virtual时, 基类函数被隐藏</p>
<ul>
<li><p>虚函数</p>
<p>virtual不能修饰构造函数、内联函数、静态成员函数</p>
</li>
</ul>
<ul>
<li><p>纯虚函数</p>
<p>基类只做能被继承，而不能被实例化</p>
</li>
</ul>
<p>​    virtual void Show() = 0;</p>
<ul>
<li><p>抽象类、接口类</p>
<p>含纯虚函数的类</p>
</li>
</ul>
<ul>
<li><p>虚表</p>
<p>存放虚函数地址的表, 可将他看作一个指针数组, 实现虚函数后, 子类虚表中的指针指向重写的函数 </p>
</li>
</ul>
<p>  每个类都有一个虚表, 类中保存一个指向对应虚表的指针</p>
<ul>
<li><p>构造函数为什么不能定义为虚函数</p>
<p>虚函数的执行依赖于虚函数表。而虚函数表需要在构造函数中进行初始化工作，让他指向正确的虚函数表。而在构造对象期间，虚函数表还没有被初始化，将无法进行。</p>
</li>
</ul>
<ul>
<li><p>类型转换</p>
<p>const_cast用于将const变量转为非const</p>
</li>
</ul>
<p>  static_cast用的最多，对于各种隐式转换，非const转const，void*转指针等, static_cast能用于多态向上转化</p>
<p>  dynamic_cast用于动态类型转换。只能用于含有虚函数的类，用于类层次间的向上和向下转化。</p>
<p>  reinterpret_cast几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用；</p>
<ul>
<li><p>explicit</p>
<p>被explicit关键字修饰的类构造函数，不能进行自动地隐式类型转换，只能显式地进行类型转换</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">public:</span><br><span class="line">	Demo();</span><br><span class="line">	explicit Demo(double a);</span><br><span class="line">	</span><br><span class="line">private:</span><br><span class="line">	int a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Demo d;</span><br><span class="line">d = 12;	错误, 去掉explicit则正确</span><br></pre></td></tr></table></figure>
<ul>
<li>vector和list</li>
</ul>
<p>vector: 底层实现是数组</p>
<p>list: 底层实现是list</p>
<ul>
<li>set和map</li>
</ul>
<p>底层实现是红黑树</p>
<ul>
<li>map和hashmap</li>
</ul>
<p>map底层是红黑树, 查找是O(lgn)</p>
<p>hashmap底层是hash表, 查找是O(1)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/算法/算法/数据结构--红黑树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/算法/算法/数据结构--红黑树/" itemprop="url">红黑树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-17T22:22:56+08:00">
                2020-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>特点</p>
<p>属于弱平衡二叉树, 对于要求严格的AVL树来说，它的旋转次数少，所以对于搜索，插入，删除操作较多的情况下，通常使用红黑树</p>
<p>根到叶子的最长路径 &lt;= 2 * 根到叶子的最短路径</p>
</li>
</ul>
<ul>
<li>性质</li>
</ul>
<ol>
<li><p>根节点是黑色</p>
</li>
<li><p>每个叶子节点(NULL节点, 不含数字)都是黑色的空节点</p>
</li>
<li><p>每个红色节点的两个子节点都是黑色</p>
</li>
<li><p>从任一节点到其每个叶子的路径都包含相同数目的黑色节点</p>
</li>
</ol>
<ul>
<li><p>插入</p>
<p>插入结点设置为红色</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/算法/算法/数据结构--字典树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/算法/算法/数据结构--字典树/" itemprop="url">字典树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-11T07:52:05+08:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h1><p>​    又称单词查找树, 用于排序和保存大量的字符串. 利用字符串的公共前缀来减少查询时间, 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串</p>
<h2 id="求最长公共前缀"><a href="#求最长公共前缀" class="headerlink" title="求最长公共前缀"></a>求最长公共前缀</h2><p>​    先找到两个树结点的最近公共祖先, 根结点到最近公共祖先结点就算最长公共前缀. 对于二叉树, 可以直接遍历; 对于非二叉树, 分别遍历两个路径, 并保存在两个vector中, 他们的前缀一定相同, 因此只要同步遍历vector即可</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://utilcoder.com/算法/算法/链表逆置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CoderUtil">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Code">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/算法/算法/链表逆置/" itemprop="url">链表逆置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-07T12:36:41+08:00">
                2020-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h1><p>​    适用于带头结点的链表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void ReverseList() &#123;</span><br><span class="line">        Node&lt;T&gt; *curr, *post;</span><br><span class="line">        curr = head-&gt;next;</span><br><span class="line">        post = curr-&gt;next;</span><br><span class="line"></span><br><span class="line">        while (post) &#123;</span><br><span class="line">            curr-&gt;next = head-&gt;next;</span><br><span class="line">            head-&gt;next = curr;</span><br><span class="line"></span><br><span class="line">            curr = post;</span><br><span class="line">            post = post-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curr-&gt;next = head-&gt;next;	/*处理`curr`指向最后一个节点*/</span><br><span class="line">        head-&gt;next = curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="CoderUtil" />
            
              <p class="site-author-name" itemprop="name">CoderUtil</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">128</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/CoderUtil" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:853130236@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://icytown.com/" title="Mega Show's Blog" target="_blank">Mega Show's Blog</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CoderUtil</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
